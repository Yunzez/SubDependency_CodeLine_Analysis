{"../snake/src/draw.rs":{"children":[{"children":[{"children":[{"children":[{"children":[{"children":[],"end_position":{"column":22,"row":6},"start_position":{"column":5,"row":6},"text":"game_coord as f64","type":"type_cast_expression"}],"end_position":{"column":23,"row":6},"start_position":{"column":4,"row":6},"text":"(game_coord as f64)","type":"parenthesized_expression"}],"end_position":{"column":36,"row":6},"start_position":{"column":4,"row":6},"text":"(game_coord as f64) * BLOCK_SIZE","type":"binary_expression"}],"end_position":{"column":1,"row":7},"start_position":{"column":40,"row":5},"text":"{\n    (game_coord as f64) * BLOCK_SIZE\n}","type":"block"}],"end_position":{"column":1,"row":7},"start_position":{"column":0,"row":5},"text":"pub fn to_coord(game_coord: f32) -> f64 {\n    (game_coord as f64) * BLOCK_SIZE\n}","type":"function_item"},{"children":[{"children":[{"children":[{"children":[{"children":[],"end_position":{"column":35,"row":10},"start_position":{"column":18,"row":10},"text":"BLOCK_SIZE as u32","type":"type_cast_expression"}],"end_position":{"column":36,"row":10},"start_position":{"column":17,"row":10},"text":"(BLOCK_SIZE as u32)","type":"parenthesized_expression"}],"end_position":{"column":36,"row":10},"start_position":{"column":4,"row":10},"text":"game_coord * (BLOCK_SIZE as u32)","type":"binary_expression"}],"end_position":{"column":1,"row":11},"start_position":{"column":44,"row":9},"text":"{\n    game_coord * (BLOCK_SIZE as u32)\n}","type":"block"}],"end_position":{"column":1,"row":11},"start_position":{"column":0,"row":9},"text":"pub fn to_coord_u32(game_coord: u32) -> u32 {\n    game_coord * (BLOCK_SIZE as u32)\n}","type":"function_item"},{"children":[{"children":[{"children":[{"children":[],"end_position":{"column":5,"row":21},"start_position":{"column":4,"row":16},"text":"rectangle(\n        color,\n        [gui_x, gui_y, BLOCK_SIZE, BLOCK_SIZE],\n        con.transform,\n        g,\n    )","type":"call_expression"}],"end_position":{"column":6,"row":21},"start_position":{"column":4,"row":16},"text":"rectangle(\n        color,\n        [gui_x, gui_y, BLOCK_SIZE, BLOCK_SIZE],\n        con.transform,\n        g,\n    );","type":"expression_statement"}],"end_position":{"column":1,"row":22},"start_position":{"column":76,"row":13},"text":"{\n    let gui_x = to_coord(x as f32);\n    let gui_y = to_coord(y as f32);\n    rectangle(\n        color,\n        [gui_x, gui_y, BLOCK_SIZE, BLOCK_SIZE],\n        con.transform,\n        g,\n    );\n}","type":"block"}],"end_position":{"column":1,"row":22},"start_position":{"column":0,"row":13},"text":"pub fn draw_block(color: Color, x: i32, y: i32, con: &Context, g: &mut G2d) {\n    let gui_x = to_coord(x as f32);\n    let gui_y = to_coord(y as f32);\n    rectangle(\n        color,\n        [gui_x, gui_y, BLOCK_SIZE, BLOCK_SIZE],\n        con.transform,\n        g,\n    );\n}","type":"function_item"},{"children":[{"children":[{"children":[{"children":[],"end_position":{"column":5,"row":45},"start_position":{"column":4,"row":35},"text":"rectangle(\n        color,\n        [\n            x,\n            y,\n            BLOCK_SIZE * (width as f64),\n            BLOCK_SIZE * (height as f64),\n        ],\n        con.transform,\n        g,\n    )","type":"call_expression"}],"end_position":{"column":6,"row":45},"start_position":{"column":4,"row":35},"text":"rectangle(\n        color,\n        [\n            x,\n            y,\n            BLOCK_SIZE * (width as f64),\n            BLOCK_SIZE * (height as f64),\n        ],\n        con.transform,\n        g,\n    );","type":"expression_statement"}],"end_position":{"column":1,"row":46},"start_position":{"column":2,"row":32},"text":"{\n    let x = to_coord(x as f32);\n    let y = to_coord(y as f32);\n    rectangle(\n        color,\n        [\n            x,\n            y,\n            BLOCK_SIZE * (width as f64),\n            BLOCK_SIZE * (height as f64),\n        ],\n        con.transform,\n        g,\n    );\n}","type":"block"}],"end_position":{"column":1,"row":46},"start_position":{"column":0,"row":24},"text":"pub fn draw_rectangle(\n    color: Color,\n    x: i32,\n    y: i32,\n    width: i32,\n    height: i32,\n    con: &Context,\n    g: &mut G2d,\n) {\n    let x = to_coord(x as f32);\n    let y = to_coord(y as f32);\n    rectangle(\n        color,\n        [\n            x,\n            y,\n            BLOCK_SIZE * (width as f64),\n            BLOCK_SIZE * (height as f64),\n        ],\n        con.transform,\n        g,\n    );\n}","type":"function_item"}],"end_position":{"column":0,"row":47},"start_position":{"column":0,"row":0},"text":"use piston_window::types::Color;\nuse piston_window::{rectangle, Context, G2d};\n\nconst BLOCK_SIZE: f64 = 25.0;\n\npub fn to_coord(game_coord: f32) -> f64 {\n    (game_coord as f64) * BLOCK_SIZE\n}\n\npub fn to_coord_u32(game_coord: u32) -> u32 {\n    game_coord * (BLOCK_SIZE as u32)\n}\n\npub fn draw_block(color: Color, x: i32, y: i32, con: &Context, g: &mut G2d) {\n    let gui_x = to_coord(x as f32);\n    let gui_y = to_coord(y as f32);\n    rectangle(\n        color,\n        [gui_x, gui_y, BLOCK_SIZE, BLOCK_SIZE],\n        con.transform,\n        g,\n    );\n}\n\npub fn draw_rectangle(\n    color: Color,\n    x: i32,\n    y: i32,\n    width: i32,\n    height: i32,\n    con: &Context,\n    g: &mut G2d,\n) {\n    let x = to_coord(x as f32);\n    let y = to_coord(y as f32);\n    rectangle(\n        color,\n        [\n            x,\n            y,\n            BLOCK_SIZE * (width as f64),\n            BLOCK_SIZE * (height as f64),\n        ],\n        con.transform,\n        g,\n    );\n}\n","type":"source_file"},"../snake/src/game.rs":{"children":[],"end_position":{"column":0,"row":158},"start_position":{"column":0,"row":0},"text":"use piston_window::types::Color;\nuse piston_window::*;\n\nuse rand::{thread_rng, Rng};\n\nuse crate::draw::{draw_block, draw_rectangle};\nuse crate::snake::{Direction, Snake};\n\nconst BACK_COLOR: Color = [0.5, 0.5, 0.5, 1.0];\nconst GAMEOVER_COLOR: Color = [0.9, 0.0, 0.0, 0.5];\nconst FOOD_COLOR: Color = [0.80, 0.00, 0.00, 1.0];\nconst BORDER_COLOR: Color = [0.00, 0.00, 0.00, 1.0];\n\nconst MOVING_PERIOD: f64 = 0.1;\nconst RESTART_TIME: f64 = 1.0;\n\npub struct Game {\n    snake: Snake,\n\n    food_exists: bool,\n    food_x: i32,\n    food_y: i32,\n\n    width: i32,\n    height: i32,\n\n    game_over: bool,\n    waiting_time: f64,\n}\n\nimpl Game {\n    pub fn new(width: i32, height: i32) -> Game {\n        Game {\n            snake: Snake::new(2, 2),\n            waiting_time: 0.0,\n            food_exists: true,\n            food_x: 6,\n            food_y: 4,\n            width,\n            height,\n            game_over: false,\n        }\n    }\n\n    pub fn key_pressed(&mut self, key: Key) {\n        if self.game_over {\n            return;\n        }\n\n        let dir = match key {\n            Key::Up => Some(Direction::Up),\n            Key::Down => Some(Direction::Down),\n            Key::Left => Some(Direction::Left),\n            Key::Right => Some(Direction::Right),\n            _ => Some(self.snake.head_direction()),\n        };\n\n        if dir.unwrap() == self.snake.head_direction().opposite() {\n            return;\n        }\n\n        self.update_snake(dir);\n    }\n\n    pub fn draw(&self, con: &Context, g: &mut G2d) {\n        self.snake.draw(con, g);\n\n        if self.food_exists {\n            draw_block(FOOD_COLOR, self.food_x, self.food_y, con, g);\n        }\n\n        draw_rectangle(BORDER_COLOR, 0, 0, self.width, 1, con, g);\n\n        draw_rectangle(BORDER_COLOR, 0, self.height - 1, self.width, 1, con, g);\n\n        draw_rectangle(BORDER_COLOR, 0, 0, 1, self.height, con, g);\n\n        draw_rectangle(BORDER_COLOR, self.width - 1, 0, 1, self.height, con, g);\n\n        if self.game_over {\n            draw_rectangle(GAMEOVER_COLOR, 0, 0, self.width, self.height, con, g);\n        }\n    }\n\n    pub fn update(&mut self, delta_time: f64) {\n        self.waiting_time += delta_time;\n\n        if self.game_over {\n            if self.waiting_time > RESTART_TIME {\n                self.restart();\n            }\n            return;\n        }\n\n        if !self.food_exists {\n            self.add_food();\n        }\n\n        if self.waiting_time > MOVING_PERIOD {\n            self.update_snake(None);\n        }\n    }\n\n    fn check_eating(&mut self) {\n        // Renamed from check_eacting\n        let (head_x, head_y): (i32, i32) = self.snake.head_position();\n        if self.food_exists && self.food_x == head_x && self.food_y == head_y {\n            self.food_exists = false;\n            self.snake.restore_tail();\n        }\n    }\n\n    fn check_if_snake_alive(&self, dir: Option<Direction>) -> bool {\n        let (next_x, next_y) = self.snake.next_head(dir);\n\n        if self.snake.overlap_tail(next_x, next_y) {\n            return false;\n        }\n\n        next_x > 0 && next_y > 0 && next_x < self.width - 1 && next_y < self.height - 1\n    }\n\n    fn add_food(&mut self) {\n        let mut rng = thread_rng();\n\n        let mut new_x = rng.gen_range(1..self.width - 1);\n        let mut new_y = rng.gen_range(1..self.height - 1);\n\n        while self.snake.overlap_tail(new_x, new_y) {\n            let mut new_x = rng.gen_range(1..self.width - 1);\n            let mut new_y = rng.gen_range(1..self.height - 1);\n        }\n\n        self.food_x = new_x;\n        self.food_y = new_y;\n        self.food_exists = true;\n    }\n\n    fn update_snake(&mut self, dir: Option<Direction>) {\n        if self.check_if_snake_alive(dir) {\n            self.snake.move_forward(dir);\n            self.check_eating();\n        } else {\n            self.game_over = true;\n        }\n\n        self.waiting_time = 0.0;\n    }\n\n    fn restart(&mut self) {\n        self.snake = Snake::new(2, 2);\n        self.waiting_time = 0.0;\n        self.food_exists = true;\n        self.food_x = 6;\n        self.food_y = 4;\n        self.game_over = false;\n    }\n}\n","type":"source_file"},"../snake/src/main.rs":{"children":[{"children":[{"children":[{"children":[{"children":[{"children":[{"children":[{"children":[{"children":[{"children":[{"children":[{"children":[],"end_position":{"column":28,"row":27},"start_position":{"column":12,"row":27},"text":"game.key_pressed","type":"field_expression"}],"end_position":{"column":33,"row":27},"start_position":{"column":12,"row":27},"text":"game.key_pressed(key)","type":"call_expression"}],"end_position":{"column":34,"row":27},"start_position":{"column":12,"row":27},"text":"game.key_pressed(key);","type":"expression_statement"}],"end_position":{"column":9,"row":28},"start_position":{"column":64,"row":26},"text":"{\n            game.key_pressed(key);\n        }","type":"block"}],"end_position":{"column":9,"row":28},"start_position":{"column":8,"row":26},"text":"if let Some(Button::Keyboard(key)) = event.press_args() {\n            game.key_pressed(key);\n        }","type":"if_expression"}],"end_position":{"column":9,"row":28},"start_position":{"column":8,"row":26},"text":"if let Some(Button::Keyboard(key)) = event.press_args() {\n            game.key_pressed(key);\n        }","type":"expression_statement"},{"children":[{"children":[{"children":[],"end_position":{"column":22,"row":29},"start_position":{"column":8,"row":29},"text":"window.draw_2d","type":"field_expression"}],"end_position":{"column":10,"row":32},"start_position":{"column":8,"row":29},"text":"window.draw_2d(&event, |c, g, t| {\n            clear(BACK_COLOR, g);\n            game.draw(&c, g);\n        })","type":"call_expression"}],"end_position":{"column":11,"row":32},"start_position":{"column":8,"row":29},"text":"window.draw_2d(&event, |c, g, t| {\n            clear(BACK_COLOR, g);\n            game.draw(&c, g);\n        });","type":"expression_statement"},{"children":[{"children":[{"children":[],"end_position":{"column":20,"row":34},"start_position":{"column":8,"row":34},"text":"event.update","type":"field_expression"}],"end_position":{"column":10,"row":36},"start_position":{"column":8,"row":34},"text":"event.update(|arg| {\n            game.update(arg.dt);\n        })","type":"call_expression"}],"end_position":{"column":11,"row":36},"start_position":{"column":8,"row":34},"text":"event.update(|arg| {\n            game.update(arg.dt);\n        });","type":"expression_statement"}],"end_position":{"column":5,"row":37},"start_position":{"column":42,"row":25},"text":"{\n        if let Some(Button::Keyboard(key)) = event.press_args() {\n            game.key_pressed(key);\n        }\n        window.draw_2d(&event, |c, g, t| {\n            clear(BACK_COLOR, g);\n            game.draw(&c, g);\n        });\n\n        event.update(|arg| {\n            game.update(arg.dt);\n        });\n    }","type":"block"}],"end_position":{"column":5,"row":37},"start_position":{"column":4,"row":25},"text":"while let Some(event) = window.next() {\n        if let Some(Button::Keyboard(key)) = event.press_args() {\n            game.key_pressed(key);\n        }\n        window.draw_2d(&event, |c, g, t| {\n            clear(BACK_COLOR, g);\n            game.draw(&c, g);\n        });\n\n        event.update(|arg| {\n            game.update(arg.dt);\n        });\n    }","type":"while_expression"}],"end_position":{"column":5,"row":37},"start_position":{"column":4,"row":25},"text":"while let Some(event) = window.next() {\n        if let Some(Button::Keyboard(key)) = event.press_args() {\n            game.key_pressed(key);\n        }\n        window.draw_2d(&event, |c, g, t| {\n            clear(BACK_COLOR, g);\n            game.draw(&c, g);\n        });\n\n        event.update(|arg| {\n            game.update(arg.dt);\n        });\n    }","type":"expression_statement"}],"end_position":{"column":1,"row":38},"start_position":{"column":10,"row":15},"text":"{\n    let (width, height) = (20, 20);\n    let mut window: PistonWindow =\n        WindowSettings::new(\"Snake\", [to_coord_u32(width), to_coord_u32(height)])\n            .exit_on_esc(true)\n            .build()\n            .unwrap();\n\n    let mut game = Game::new(width as i32, height as i32);\n\n    while let Some(event) = window.next() {\n        if let Some(Button::Keyboard(key)) = event.press_args() {\n            game.key_pressed(key);\n        }\n        window.draw_2d(&event, |c, g, t| {\n            clear(BACK_COLOR, g);\n            game.draw(&c, g);\n        });\n\n        event.update(|arg| {\n            game.update(arg.dt);\n        });\n    }\n}","type":"block"}],"end_position":{"column":1,"row":38},"start_position":{"column":0,"row":15},"text":"fn main() {\n    let (width, height) = (20, 20);\n    let mut window: PistonWindow =\n        WindowSettings::new(\"Snake\", [to_coord_u32(width), to_coord_u32(height)])\n            .exit_on_esc(true)\n            .build()\n            .unwrap();\n\n    let mut game = Game::new(width as i32, height as i32);\n\n    while let Some(event) = window.next() {\n        if let Some(Button::Keyboard(key)) = event.press_args() {\n            game.key_pressed(key);\n        }\n        window.draw_2d(&event, |c, g, t| {\n            clear(BACK_COLOR, g);\n            game.draw(&c, g);\n        });\n\n        event.update(|arg| {\n            game.update(arg.dt);\n        });\n    }\n}","type":"function_item"}],"end_position":{"column":0,"row":39},"start_position":{"column":0,"row":0},"text":"extern crate piston_window;\nextern crate rand;\nuse tree_sitter::{Language, Parser};\n\nmod draw;\nmod game;\nmod snake;\nuse piston_window::types::Color;\nuse piston_window::*;\n\nuse draw::to_coord_u32;\nuse game::Game;\n\nconst BACK_COLOR: Color = [0.5, 0.5, 0.5, 1.0];\n\nfn main() {\n    let (width, height) = (20, 20);\n    let mut window: PistonWindow =\n        WindowSettings::new(\"Snake\", [to_coord_u32(width), to_coord_u32(height)])\n            .exit_on_esc(true)\n            .build()\n            .unwrap();\n\n    let mut game = Game::new(width as i32, height as i32);\n\n    while let Some(event) = window.next() {\n        if let Some(Button::Keyboard(key)) = event.press_args() {\n            game.key_pressed(key);\n        }\n        window.draw_2d(&event, |c, g, t| {\n            clear(BACK_COLOR, g);\n            game.draw(&c, g);\n        });\n\n        event.update(|arg| {\n            game.update(arg.dt);\n        });\n    }\n}\n","type":"source_file"},"../snake/src/snake.rs":{"children":[],"end_position":{"column":1,"row":145},"start_position":{"column":0,"row":0},"text":"use std::collections::LinkedList;\nuse piston_window::{Context, G2d, math};\nuse piston_window::types::Color;\n\nuse crate::draw::{draw_block, draw_rectangle};\n\nconst SNAKE_COLOR: Color = [0.00, 0.80, 0.00, 1.0];\n\n\n#[derive(Copy, Clone, PartialEq)]\npub enum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n\nimpl Direction {\n    pub fn opposite(&self) -> Direction {\n        match *self {\n            Direction::Up => Direction::Down,\n            Direction::Down => Direction::Up,\n            Direction::Left => Direction::Right,\n            Direction::Right => Direction::Left,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct Block {\n    x: i32,\n    y: i32,\n}\n\npub struct Snake {\n    direction: Direction,\n    body: LinkedList<Block>,\n    tail: Option<Block>,\n}\n\n\nimpl Snake {\n    pub fn new(x: i32, y: i32) -> Snake{\n        let mut body: LinkedList<Block> = LinkedList::new();\n        body.push_back(Block {\n            x: x + 2, \n            y,\n        });\n        body.push_back(Block {\n            x: x+1,\n            y,\n        });\n        body.push_back(Block {\n            x,\n            y\n        });\n\n        Snake {\n            direction: Direction::Right,\n            body,\n            tail: None,\n        }\n    }\n\n    pub fn draw(&self, con: &Context, g:&mut G2d) {\n        for block in &self.body {\n            draw_block(SNAKE_COLOR, block.x, block.y, con, g);\n        }\n    }\n    \n    pub fn head_position(&self) -> (i32, i32) {\n        let head_block = self.body.front().unwrap();\n        (head_block.x, head_block.y)\n    }\n\n    pub fn move_forward(&mut self, dir: Option<Direction>) {\n        match dir {\n            Some(d) => self.direction = d,\n            None =>(),\n        }\n\n        let (last_x, last_y): (i32, i32) = self.head_position();\n\n        let new_block = match self.direction {\n            Direction::Up => Block {\n                x: last_x,\n                y: last_y -1,\n            },\n            Direction::Down => Block {\n                x: last_x,\n                y: last_y +1,\n            },\n            Direction::Left => Block {\n                x: last_x -1,\n                y: last_y,\n            },\n            Direction::Right => Block {\n                x: last_x +1,\n                y: last_y,\n            }\n        };\n        self.body.push_front(new_block);\n        let removed_bloc = self.body.pop_back().unwrap();\n        self.tail = Some(removed_bloc);\n    }\n\n    pub fn head_direction(&self) -> Direction {\n        self.direction\n    }\n\n    pub fn next_head(&self, dir:Option<Direction>) -> (i32, i32) {\n        let (head_x, head_y): (i32, i32) = self.head_position();\n\n        let mut moving_dir = self.direction;\n        match dir {\n            Some(d) => moving_dir = d,\n            None => (),\n        }\n\n        match moving_dir {\n            Direction::Up => (head_x, head_y -1),\n            Direction::Down => (head_x, head_y +1),\n            Direction::Left => (head_x -1, head_y),\n            Direction::Right => (head_x +1, head_y),\n        }\n    }\n\n    pub fn restore_tail(&mut self) {\n        let blk = self.tail.clone().unwrap();\n        self.body.push_back(blk);\n    }\n\n    pub fn overlap_tail(&self, x:i32, y:i32) -> bool {\n        let mut ch = 0;\n        for block in &self.body {\n            if x == block.x && y == block.y {\n                return true;\n            }\n            ch += 1;\n            if ch == self.body.len() -1 {\n                break;\n            }\n        }\n        return false;\n    }\n}","type":"source_file"}}